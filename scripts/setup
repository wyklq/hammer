#
# This file is part of the HAMMER build system.
#
# Copyright (C) 2012-2014 Aaro Koskinen <aaro.koskinen@iki.fi>
#
# Licensed under the GNU General Public License version 2 (GPLv2).
#

if [ "$1" != "list" ]
then
	set -x
fi
set -e

export SHELL=/bin/sh
export LC_ALL=C

test -e "$HOME/.hammerconfig" && . "$HOME/.hammerconfig"

BASEDIR=`cd $(dirname $0)/.. && pwd`
BUILD_BASE="$BASEDIR/work/$HW_ARCH"

pkg_patch ()
{
	PATCH_DIR=`echo "$BASEDIR/upstream/$PKG_NAME" | sed 's/-$//'`
	if [ ! -d "$PATCH_DIR" ]
	then
		return
	fi
	cd "$1"
	PATCH_DIRS=$PATCH_DIR
	if [ -n "$PKG_VERSION" -a -d "$PATCH_DIR/$PKG_VERSION" ]
	then
		PATCH_DIRS="$PATCH_DIR/$PKG_VERSION $PATCH_DIRS"
	fi
	for D in $PATCH_DIRS
	do
		for P in `ls $D/*.patch | sort`
		do
			patch -p1 < $P
		done
	done
}

_pkg_info ()
{
	if [ -z "$PKG_URL" ]
	then
		PKG_DATA=`awk ' { if ($1 == "'$P'") { print $0; exit } } ' \
			  "$BASEDIR/upstream/packages"`
		if [ -z "$PKG_DATA" ]
		then
			echo "$0: upstream location of package $P missing"
			exit 1
		fi
		PKG_URL=`echo $PKG_DATA | awk ' { print $2 } '`
		PKG_TYPE=`echo $PKG_DATA | awk ' { print $3 } '`
		PKG_HASH=`echo $PKG_DATA | awk ' { print $4 } '`
		if [ "$PKG_TYPE" = "git" ]
		then
			PKG_SHA1="$PKG_HASH"
		else
			PKG_MD5="$PKG_HASH"
		fi
	fi
	if [ -z "$PKG_URL" ]
	then
		echo "PKG_URL for package $P is not defined."
		exit 1
	elif ! (echo "$PKG_URL" | grep -q '^[a-z][a-z]*://')
	then
		if [ "$PKG_TYPE" = "git" ]
		then
			URL_BASE="$PKG_GIT_BASE"
		else
			URL_BASE="$PKG_WWW_BASE"
		fi
		if [ -z "$URL_BASE" ]
		then
			echo "URL base for $PKG_TYPE package $P missing."
			exit 1
		fi
		PKG_URL="$URL_BASE$PKG_URL"
	fi
	if [ -z "$PKG_TYPE" ]
	then
		PKG_TYPE="tarball"
	fi
	if [ -z "$PKG_DATE" ]
	then
		PKG_DATE=1970-01-01
	fi
}

_pkg_git_verify ()
{
	if ! (cd "$PKG_GIT"; git rev-parse --quiet --verify \
	      "$PKG_VERSION^{commit}")
	then
		echo "$0: $PKG_VERSION missing/corrupted in $PKG_GIT"
		return 1
	fi
}

_pkg_fetch ()
{
	mkdir -p "$BASEDIR/work/pkg"
	if [ "$PKG_TYPE" = "git" ]
	then
		git clone --bare "$PKG_URL" "$PKG_GIT" || rm -rf "$PKG_GIT"
		_pkg_git_verify || rm -rf "$PKG_GIT"
	else
		curl -L -k -o "$PKG_SOURCE.tmp" "$PKG_URL"
		MD5SUM=`md5sum "$PKG_SOURCE.tmp" | awk ' { print $1 } '`
		if [ "$MD5SUM" = "$PKG_MD5" ]
		then
			mv "$PKG_SOURCE.tmp" "$PKG_SOURCE"
		else
			rm -f ".$PKG_FILENAME"
		fi
	fi
}

pkg_download ()
{
	P=$PKG
	if [ ! -e "$BASEDIR/upstream/packages" ]
	then
		if [ -z "$PKG_FILENAME" ]
		then
			echo "$0: $PKG PKG_FILENAME missing"
			exit 1
		fi
		PKG_SOURCE="$BASEDIR/work/pkg/$PKG_FILENAME"
		return
	fi
	_pkg_info
	if [ -z "$PKG_FILENAME" ]
	then
		PKG_FILENAME=`basename "$PKG_URL"`
		if [ -z "$PKG_FILENAME" ]
		then
			echo "$0: $PKG PKG_URL invalid: $PKG_URL"
			exit 1
		fi
	fi
	PKG_SOURCE="$BASEDIR/work/pkg/$PKG_FILENAME"
	if [ -z "$PKG" ]
	then
		echo "$0: PKG not defined"
		exit 1
	fi
	exec 9<"$BASEDIR/upstream/packages"
	flock -x 9
	PKG_GIT=`echo "$BASEDIR/work/git/$PKG_NAME" | sed 's/-$//'`
	if [ "$PKG_TYPE" = "git" ]
	then
		if [ ! -d "$PKG_GIT" ]
		then
			_pkg_fetch $P
		elif ! _pkg_git_verify
		then
			(cd "$PKG_GIT"; git fetch "$PKG_URL";
			 git fetch --tags "$PKG_URL"; _pkg_git_verify)
		fi
	elif [ ! -e "$PKG_SOURCE" ]
	then
		_pkg_fetch $P
		if [ ! -e "$PKG_SOURCE" ]
		then
			echo "$0: $PKG package missing: $PKG_SOURCE"
			exit 1
		fi
	fi
	exec 9<&-
}

_pkg_unpack ()
{
	if [ $P = $PKG ]
	then
		test -d "$PKG_UNPACK" && rm -rf "$PKG_UNPACK"
		if [ -n "$PKG_STAGING" ]
		then
			test -d "$PKG_STAGING" && rm -rf "$PKG_STAGING"
			mkdir -p "$PKG_STAGING"
		else
			echo "$0: no staging directory specified"
			exit 1
		fi
		mkdir -p "$PKG_UNPACK"
	fi
	cd "$PKG_UNPACK"
	if [ "$PKG_TYPE" = "git" ]
	then
		if ! ((cd "$PKG_GIT"; git archive --format=tar --prefix=./ \
		      "$PKG_VERSION") | tar xf -)
		then
			echo "$0: could not export $PKG_VERSION from $PKG_GIT"
			exit 1
		fi
	elif ! tar xaf "$PKG_SOURCE" $PKG_FLAT
	then
		echo "$0: could not unpack $PKG_SOURCE"
		exit 1
	fi
	pkg_patch "$PKG_UNPACK"
}

pkg_unpack_real ()
{
	if [ -z "$PKG_DIR" ]
	then
		echo "$0: PKG_DIR not defined"
		exit 1
	fi
	if [ -d "$PKG_SOURCES" ]
	then
		rm -rf "$PKG_DIR"
		cp -pr "$PKG_SOURCES" "$PKG_DIR"
	else
		pkg_download
		PKG_UNPACK="$PKG_DIR"
		_pkg_unpack
	fi
}

pkg_unpack ()
{
	PKG_FLAT="--strip-components=1"
	pkg_unpack_real
	cd "$PKG_DIR"
}

pkg_unpack_flat ()
{
	PKG_FLAT=""
	pkg_unpack_real
	cd "$PKG_DIR"
}

_pkg_unpack_shared ()
{
	PKG_FLAT="--strip-components=1"
	PKG_SHARED="$BASEDIR/work/shared/$PKG"
	if [ -z "$PKG" ]
	then
		echo "$0: PKG not defined"
		exit 1
	elif [ -z "$PKG_SHARED" ]
	then
		echo "$0: PKG_SHARED not defined"
		exit 1
	fi
	pkg_download
	mkdir -p "$BASEDIR/work/shared"
	LOCK="$BASEDIR/work/shared/.$PKG.lock"
	touch "$LOCK"
	exec 9<"$LOCK"
	flock -x 9
	if [ -e "$PKG_SHARED" ]
	then
		exec 9<&-
		test -d $PKG_DIR-build && rm -rf $PKG_DIR-build
		if [ -n "$PKG_STAGING" ]
		then
			test -d "$PKG_STAGING" && rm -rf "$PKG_STAGING"
			mkdir -p "$PKG_STAGING"
		else
			echo "$0: no staging directory specified"
			exit 1
		fi
		mkdir -p "$PKG_DIR-build"
		cd "$PKG_DIR-build"
		return
	fi
	PKG_UNPACK="$BASEDIR/work/shared/.$PKG"
	_pkg_unpack
	mv "$PKG_UNPACK" "$PKG_SHARED"
	exec 9<&-
}

pkg_unpack_shared ()
{
	if [ -d "$PKG_SOURCES" ]
	then
		PKG_SHARED="$PKG_SOURCES"
	else
		_pkg_unpack_shared
	fi
	test -d "$PKG_DIR-build" && rm -rf "$PKG_DIR-build"
	mkdir -p "$PKG_DIR-build"
	cd "$PKG_DIR-build"
}

pkg_install ()
{
	TARGET_DIR="$1"
	shift
	if [ -z "$TARGET_DIR" ]
	then
		echo "$0: target dir not specified"
		exit 1
	elif [ -z "$PKG_STAGING" ]
	then
		echo "$0: no staging directory specified"
		exit 1
	fi
	SUBTARGET="$1"
	if [ -n "$SUBTARGET" ]
	then
		shift
		SUBTARGET="-$SUBTARGET"
		DIRS=$*
	else
		DIRS="/"
	fi
	mkdir -p "$TARGET_DIR"
	rm -f "$PKG_STAGING/.files"
	touch "$PKG_STAGING/.files"
	for D in $DIRS
	do
		"$BASEDIR/scripts/strip_tree.pl" "$PKG_STAGING/$D/$STRIP_BASE"
		(cd "$PKG_STAGING"; \
			find ./$D -type f -o -type l | \
			sed 's/^\.\/\/*//' | \
			grep -v '^\.files$' >> .files)
	done
	(cd "$PKG_STAGING"; tar cf - -T .files) | (cd "$TARGET_DIR"; tar xfp -)
	mv "$PKG_STAGING/.files" \
		"$PKG_STAGING/../${PKG_BUILD_NAME}files$SUBTARGET"
	touch "$PKG_STAGING/../.modified"
}

pkg_replace ()
{
	REPLACE_DIR=`echo $1|sed 's/\/*$//'`
	if [ -z "$REPLACE_DIR" ]
	then
		echo "$0: target dir not specified"
		exit 1
	fi
	REPLACE_NEW="$REPLACE_DIR.new"
	REPLACE_OLD="$REPLACE_DIR.old"
	pkg_install "$REPLACE_NEW"
	if [ -d "$REPLACE_DIR" ]
	then
		mv "$REPLACE_DIR" "$REPLACE_OLD"
	fi
	mv "$REPLACE_NEW" "$REPLACE_DIR"
	if [ -d "$REPLACE_OLD" ]
	then
		rm -rf "$REPLACE_OLD"
	fi
}

pkg_dummy ()
{
	if [ -z "$PKG_STAGING" ]
	then
		echo "$0: no staging directory specified"
		exit 1
	fi
	DIR=`dirname "$PKG_STAGING"`
	mkdir -p $DIR
	touch "$DIR/${PKG_BUILD_NAME}files"
}

pkg_cleanup ()
{
	if [ -d "$PKG_DIR-build" ]
	then
		rm -rf "$PKG_DIR-build"
	else
		rm -rf "$PKG_DIR"
	fi
	test -d "$PKG_STAGING" && rm -rf "$PKG_STAGING"
	return 0
}

pkg_native_pre ()
{
	PKG_SCRIPT="$PKG_STAGING/$BUILD_NATIVE/native/build-$PKG_BUILD_NAME.sh"
	PKG_SCRIPT=$(echo "$PKG_SCRIPT" | sed 's/-\.sh$/.sh/')
	pkg_download
	rm -rf "$PKG_STAGING"
	mkdir -p "$PKG_STAGING/$BUILD_NATIVE/native"
	echo "#!/bin/sh" > "$PKG_SCRIPT"
	[ -n "$*" ] && echo "# dependencies: $*" >> "$PKG_SCRIPT"
	cat << EOF >> "$PKG_SCRIPT"

set -e

PKG_NAME=$PKG_NAME
PKG_VERSION=$PKG_VERSION
PKG_FILENAME=$PKG_FILENAME
PKG_BUILD_NAME=$PKG_BUILD_NAME

. ./setup

EOF
}

pkg_native_post ()
{
	chmod 755 "$PKG_SCRIPT"
	mkdir -p "$PKG_STAGING/$BUILD_NATIVE/work/pkg"
	install -p -m 644 "$PKG_SOURCE" "$PKG_STAGING/$BUILD_NATIVE/work/pkg"
	PATCH_DIR=`echo "$BASEDIR/upstream/$PKG_NAME" | sed 's/-$//'`
	if [ -d "$PATCH_DIR" ]
	then
		mkdir "$PKG_STAGING/$BUILD_NATIVE/upstream"
		cp -pr "$PATCH_DIR" "$PKG_STAGING/$BUILD_NATIVE/upstream"
	fi
	pkg_install "$BUILD_ROOTFS"
	pkg_cleanup
}

. "$BASEDIR/config/$HW_ARCH/setup"

if [ -n "$HW_BOARD" ]
then
	IMAGE_KERNEL="$HW_BOARD-`basename "$LINUX_BINARY"`"
	UIMAGE_KERNEL="$HW_BOARD-uimage-kernel"
	IMAGE_INITRAMFS="$HW_BOARD-initramfs"
	UIMAGE_INITRAMFS="$HW_BOARD-uimage-initramfs"
	BOARD_SETUP="$BASEDIR/config/$HW_ARCH/$HW_BOARD/setup"
	test -e "$BOARD_SETUP" && . "$BOARD_SETUP"
fi

PKG_NAME_FIXED=$(echo "$PKG_NAME" | sed 's/[_.]$/-/;s/[^-]$/&-/')

PKG_SOURCES=$(echo "$PKG_NAME_FIXED" | sed 's/-$//;s/-/_/g')_sources
PKG_SOURCES=$(printenv $PKG_SOURCES || true)

if [ -z "$PKG_BUILD_NAME" ]
then
	PKG_BUILD_NAME="$PKG_NAME_FIXED"
fi

PKG_STAGING=""
if [ -n "$PKG_NAME" ]
then
	if [ -z "$PKG_VERSION" ]
	then
		echo "$0: package version missing: $PKG_BUILD_NAME"
		exit 1
	fi
	PKG=$PKG_NAME$PKG_VERSION
	PKG_DIR="$BUILD_BASE$PKG_DIR_ADD/$PKG_BUILD_NAME$PKG_VERSION"
	PKG_STAGING="$BUILD_BASE/$BUILD_SUBSYSTEM/build/${PKG_BUILD_NAME}pkg"
fi

BUILD_TOOLCHAIN="$BUILD_BASE/toolchain"
BUILD_UTILS=$BASEDIR/work/host/utils
export PATH="$BUILD_TOOLCHAIN/bin:$BUILD_UTILS/bin:$PATH"

BUILD_INITRAMFS="$BUILD_BASE/initramfs/$TOOL_TRIPLET"
BUILD_IMAGES=$BASEDIR/work

LIB_NAME=${LIB_NAME:-lib}

export LIB_NAME
export MAKEFLAGS
export WEAK_DEPS

. ../scripts/setup.local

test -n "$1" && . "../scripts/setup.$1"

return 0
